This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    push.yml
    release.yml
.specstory/
  .what-is-this.md
reference/
  codex-tldr.txt
src/
  claif_cod/
    __init__.py
    cli.py
    client.py
    transport.py
    types.py
tests/
  test_package.py
.cursorrules
.gitignore
.pre-commit-config.yaml
AGENTS.md
CHANGELOG.md
CLAUDE.md
GEMINI.md
LICENSE
pyproject.toml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Comprehensive README documentation
- Complete pyproject.toml configuration
- CLI entry point `claif-cod`
- Full development dependencies setup
- Proper build configuration for wheel and sdist

### Changed
- Updated package description and keywords
- Fixed import paths from relative to absolute
- Improved code formatting and linting compliance
- Enhanced project metadata

### Fixed
- Import errors in all modules
- Missing newlines at end of files
- Ruff configuration issues

## [0.1.0] - 2024-01-01

### Added
- Initial release
- Basic Codex CLI integration
- Fire-based command-line interface
- Async subprocess transport layer
- Support for multiple action modes (review, interactive, full-auto)
- Rich terminal output with progress indicators
- Model management commands
- Configuration system integration with CLAIF
- Type definitions and data structures
- Error handling and timeout protection
</file>

<file path=".github/workflows/push.yml">
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/claif_cod --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/claif_cod
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path=".specstory/.what-is-this.md">
# SpecStory Artifacts Directory
    
This directory is automatically created and maintained by the SpecStory extension to preserve your AI chat history.
    
## What's Here?
    
- `.specstory/history`: Contains auto-saved markdown files of your AI coding sessions
    - Each file represents a separate AI chat session
    - If you enable auto-save, files are automatically updated as you work
    - You can enable/disable the auto-save feature in the SpecStory settings, it is disabled by default
- `.specstory/.project.json`: Contains the persistent project identity for the current workspace
    - This file is only present if you enable AI rules derivation
    - This is used to provide consistent project identity of your project, even as the workspace is moved or renamed
- `.specstory/ai_rules_backups`: Contains backups of the `.cursor/rules/derived-cursor-rules.mdc` or the `.github/copilot-instructions.md` file
    - Backups are automatically created each time the `.cursor/rules/derived-cursor-rules.mdc` or the `.github/copilot-instructions.md` file is updated
    - You can enable/disable the AI Rules derivation feature in the SpecStory settings, it is disabled by default
- `.specstory/.gitignore`: Contains directives to exclude non-essential contents of the `.specstory` directory from version control
    - Add `/history` to exclude the auto-saved chat history from version control

## Valuable Uses
    
- Capture: Keep your context window up-to-date when starting new Chat/Composer sessions via @ references
- Search: For previous prompts and code snippets 
- Learn: Meta-analyze your patterns and learn from your past experiences
- Derive: Keep the AI on course with your past decisions by automatically deriving rules from your AI interactions
    
## Version Control
    
We recommend keeping this directory under version control to maintain a history of your AI interactions. However, if you prefer not to version these files, you can exclude them by adding this to your `.gitignore`:
    
```
.specstory/**
```

We recommend __not__ keeping the `.specstory/ai_rules_backups` directory under version control if you are already using git to version your AI rules, and committing regularly. You can exclude it by adding this to your `.gitignore`:

```
.specstory/ai_rules_backups
```

## Searching Your Codebase
    
When searching your codebase, search results may include your previous AI coding interactions. To focus solely on your actual code files, you can exclude the AI interaction history from search results.
    
To exclude AI interaction history:
    
1. Open the "Find in Files" search in Cursor or VSCode (Cmd/Ctrl + Shift + F)
2. Navigate to the "files to exclude" section
3. Add the following pattern:
    
```
.specstory/*
```
    
This will ensure your searches only return results from your working codebase files.

## Notes

- Auto-save only works when Cursor or VSCode flushes sqlite database data to disk. This results in a small delay after the AI response is complete before SpecStory can save the history.

## Settings
    
You can control auto-saving behavior in Cursor or VSCode:
    
1. Open Cursor/Code → Settings → VS Code Settings (Cmd/Ctrl + ,)
2. Search for "SpecStory"
3. Find "Auto Save" setting to enable/disable
    
Auto-save occurs when changes are detected in the sqlite database, or every 2 minutes as a safety net.
</file>

<file path="reference/codex-tldr.txt">
# OPENAI CODEX CLI JS


This API documentation provides a detailed overview of the `codex` repository, which is a command-line interface (CLI) tool for interacting with OpenAI's Codex models. The repository is organized into two main parts: `codex-cli`, a Node.js-based CLI, and `codex-rs`, a Rust-based implementation.

## \<u\>**File Hierarchy**\</u\>

The repository has the following directory structure:

```
codex-cli/
├── bin/
│   └── codex.js
├── examples/
│   ├── build-codex-demo/
│   ├── camerascii/
│   ├── impossible-pong/
│   └── prompt-analyzer/
├── scripts/
├── src/
│   ├── components/
│   ├── hooks/
│   └── utils/
└── tests/
codex-rs/
├── ansi-escape/
├── apply-patch/
├── cli/
├── common/
├── core/
├── docs/
├── exec/
├── execpolicy/
├── file-search/
├── linux-sandbox/
├── login/
├── mcp-client/
├── mcp-server/
├── mcp-types/
├── scripts/
└── tui/
```

-----

## \<u\>**`codex-cli` API Reference**\</u\>

### **`bin/codex.js`**

  * **Purpose:** This is the main entry point for the `codex-cli`. It determines whether to run the JavaScript implementation or a pre-compiled Rust binary based on the `CODEX_RUST` environment variable.
  * **Usage:**
    ```bash
    node bin/codex.js [options] [prompt]
    ```

-----

### **`examples/`**

This directory contains several example projects that demonstrate how to use the `codex-cli`. Each example has a `run.sh` script to execute the task and a `task.yaml` file that defines the prompt for the Codex model.

  * **`build-codex-demo`**: Re-implements the original OpenAI Codex demo, creating a web-based interface for interacting with the Codex model.
  * **`camerascii`**: Creates a webpage that uses a webcam to generate ASCII art from the video feed.
  * **`impossible-pong`**: A simple Pong game with different difficulty levels.
  * **`prompt-analyzer`**: A data science application for clustering and analyzing text prompts.

-----

### **`scripts/`**

This directory contains various build and utility scripts for the `codex-cli`.

  * **`build_container.sh`**: Builds a Docker container for the `codex-cli`.
  * **`init_firewall.sh`**: Initializes a firewall for the Docker container, restricting network access to only the necessary domains.
  * **`install_native_deps.sh`**: Installs native dependencies for the `codex-cli`, including the Rust-based sandbox binaries.
  * **`run_in_container.sh`**: A wrapper script for running the `codex-cli` inside a Docker container.
  * **`stage_release.sh`**: Stages a new release of the `codex-cli` package for `npm`.

-----

### **`src/`**

This directory contains the source code for the `codex-cli`, written in TypeScript and React.

#### **`components/`**

This directory contains the React components that make up the user interface of the `codex-cli`.

  * **`chat/`**: Components related to the chat interface, such as message history, input, and response display.
  * **`onboarding/`**: Components for the initial onboarding and approval mode selection.
  * **`select-input/`**: A reusable select input component.
  * **`vendor/`**: Third-party components, such as spinners and text inputs.

#### **`hooks/`**

This directory contains custom React hooks used in the `codex-cli`.

  * **`use-confirmation.ts`**: A hook for handling confirmation prompts.
  * **`use-terminal-size.ts`**: A hook for getting the current terminal size.

#### **`utils/`**

This directory contains utility functions for various tasks, such as handling agent loops, managing files, and interacting with the OpenAI API.

  * **`agent/`**: Contains the core logic for the agent loop, including sandboxing and command execution.
  * **`logger/`**: A simple logger for debugging.
  * **`singlepass/`**: Utilities for the "full-context" editing mode.
  * **`storage/`**: Functions for managing command history and saving rollouts.

-----

## \<u\>**`codex-rs` API Reference**\</u\>

### **`ansi-escape/`**

  * **Purpose:** A small utility crate for parsing ANSI escape codes in terminal output.

### **`apply-patch/`**

  * **Purpose:** A library for applying patches to files in a format similar to `git apply`.

### **`cli/`**

  * **Purpose:** The main entry point for the Rust-based `codex` CLI. It parses command-line arguments and dispatches to the appropriate subcommands.

### **`common/`**

  * **Purpose:** A crate for sharing common utilities and types across the `codex-rs` workspace.

### **`core/`**

  * **Purpose:** The core library for the `codex-rs` implementation, containing the main `Codex` struct and the logic for interacting with the OpenAI API.

### **`docs/`**

  * **Purpose:** Contains documentation for the `codex-rs` project, including the protocol specification.

### **`exec/`**

  * **Purpose:** A library for executing shell commands and managing sandboxing.

### **`execpolicy/`**

  * **Purpose:** A tool for defining and enforcing execution policies for shell commands.

### **`file-search/`**

  * **Purpose:** A utility for searching for files in a directory.

### **`linux-sandbox/`**

  * **Purpose:** A library for creating and managing sandboxes on Linux using Landlock and seccomp.

### **`login/`**

  * **Purpose:** A utility for handling the login flow with ChatGPT to obtain an API key.

### **`mcp-client/` and `mcp-server/`**

  * **Purpose:** These crates implement the Model Context Protocol (MCP) for communicating with external tools and services.

### **`mcp-types/`**

  * **Purpose:** Contains the generated types for the Model Context Protocol.

### **`scripts/`**

  * **Purpose:** Contains build and utility scripts for the `codex-rs` project.

### **`tui/`**

  * **Purpose:** A terminal user interface (TUI) for interacting with the `codex-rs` agent.

-----

This documentation provides a high-level overview of the `codex` repository. For more detailed information, please refer to the source code and the individual `README.md` files in each directory.
  Usage
    $ codex [options] <prompt>
    $ codex completion <bash|zsh|fish>

  Options
    --version                       Print version and exit

    -h, --help                      Show usage and exit
    -m, --model <model>             Model to use for completions (default: codex-mini-latest)
    -p, --provider <provider>       Provider to use for completions (default: openai)
    -i, --image <path>              Path(s) to image files to include as input
    -v, --view <rollout>            Inspect a previously saved rollout instead of starting a session
    --history                       Browse previous sessions
    --login                         Start a new sign in flow
    --free                          Retry redeeming free credits
    -q, --quiet                     Non-interactive mode that only prints the assistant's final output
    -c, --config                    Open the instructions file in your editor
    -w, --writable-root <path>      Writable folder for sandbox in full-auto mode (can be specified multiple times)
    -a, --approval-mode <mode>      Override the approval policy: 'suggest', 'auto-edit', or 'full-auto'

    --auto-edit                Automatically approve file edits; still prompt for commands
    --full-auto                Automatically approve edits and commands when executed in the sandbox

    --no-project-doc           Do not automatically include the repository's 'AGENTS.md'
    --project-doc <file>       Include an additional markdown file at <file> as context
    --full-stdout              Do not truncate stdout/stderr from command outputs
    --notify                   Enable desktop notifications for responses

    --disable-response-storage Disable server‑side response storage (sends the
                               full conversation context with every request)

    --flex-mode               Use "flex-mode" processing mode for the request (only supported
                              with models o3 and o4-mini)

    --reasoning <effort>      Set the reasoning effort level (low, medium, high) (default: high)

  Dangerous options
    --dangerously-auto-approve-everything
                               Skip all confirmation prompts and execute commands without
                               sandboxing. Intended solely for ephemeral local testing.

  Experimental options
    -f, --full-context         Launch in "full-context" mode which loads the entire repository
                               into context and applies a batch of edits in one go. Incompatible
                               with all other flags, except for --model.

  Examples
    $ codex "Write and run a python program that prints ASCII art"
    $ codex -q "fix build issues"
    $ codex completion bash
</file>

<file path="src/claif_cod/cli.py">
"""Fire-based CLI for CLAIF Codex wrapper."""

import asyncio
import os
import sys
import time
from pathlib import Path
from typing import Optional, Union

import fire
from rich.console import Console
from rich.live import Live
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table

from claif.common import (
    get_logger,
    format_response,
    format_metrics,
    Config,
    load_config,
    ResponseMetrics,
    Provider,
)
from .client import query
from .types import CodexOptions


logger = get_logger(__name__)
console = Console()


class CodexCLI:
    """CLAIF Codex CLI with Fire interface."""

    def __init__(self, config_file: str | None = None, verbose: bool = False):
        """Initialize CLI with optional config file."""
        self.config = load_config(config_file)
        if verbose:
            self.config.verbose = True
        logger.debug("Initialized Codex CLI")

    def query(
        self,
        prompt: str,
        model: str = "o4-mini",
        temperature: float | None = None,
        max_tokens: int | None = None,
        top_p: float | None = None,
        working_dir: str | None = None,
        action_mode: str = "review",
        auto_approve: bool = False,
        full_auto: bool = False,
        timeout: int | None = None,
        output_format: str = "text",
        show_metrics: bool = False,
    ) -> None:
        """Execute a query to Codex.

        Args:
            prompt: The prompt to send
            model: Model to use (default: o4-mini)
            temperature: Sampling temperature (0-1)
            max_tokens: Maximum tokens in response
            top_p: Top-p sampling parameter
            working_dir: Working directory for code execution
            action_mode: Action mode (full-auto, interactive, review)
            auto_approve: Auto-approve all actions
            full_auto: Full automation mode
            timeout: Timeout in seconds
            output_format: Output format (text, json, code)
            show_metrics: Show response metrics
        """
        options = CodexOptions(
            model=model,
            temperature=temperature,
            max_tokens=max_tokens,
            top_p=top_p,
            working_dir=Path(working_dir) if working_dir else None,
            action_mode=action_mode,
            auto_approve_everything=auto_approve,
            full_auto=full_auto,
            timeout=timeout,
            verbose=self.config.verbose,
        )

        start_time = time.time()

        try:
            # Run async query
            messages = asyncio.run(self._query_async(prompt, options))

            # Format and display response
            for message in messages:
                if output_format == "code":
                    # Special handling for code blocks
                    self._display_code_message(message)
                else:
                    formatted = format_response(message, output_format)
                    console.print(formatted)

            # Show metrics if requested
            if show_metrics:
                duration = time.time() - start_time
                metrics = ResponseMetrics(
                    duration=duration,
                    provider=Provider.CODEX,
                    model=model,
                )
                console.print("\n" + format_metrics(metrics))

        except Exception as e:
            console.print(f"[red]Error: {e}[/red]")
            if self.config.verbose:
                console.print_exception()
            sys.exit(1)

    async def _query_async(self, prompt: str, options: CodexOptions) -> list:
        """Execute async query and collect messages."""
        messages = []
        async for message in query(prompt, options):
            messages.append(message)
        return messages

    def _display_code_message(self, message) -> None:
        """Display message with code block highlighting."""
        content = message.content
        if isinstance(content, str):
            # Check for code blocks in markdown format
            if "```" in content:
                parts = content.split("```")
                for i, part in enumerate(parts):
                    if i % 2 == 0:
                        # Regular text
                        if part.strip():
                            console.print(part.strip())
                    else:
                        # Code block
                        lines = part.strip().split("\n", 1)
                        language = lines[0] if lines else ""
                        code = lines[1] if len(lines) > 1 else part

                        from rich.syntax import Syntax

                        syntax = Syntax(code, language or "text", theme="monokai")
                        console.print(syntax)
            else:
                console.print(content)
        else:
            # Handle structured content
            console.print(format_response(message))

    def stream(
        self,
        prompt: str,
        model: str = "o4-mini",
        temperature: float | None = None,
        working_dir: str | None = None,
        action_mode: str = "review",
        auto_approve: bool = False,
    ) -> None:
        """Stream responses from Codex with live display.

        Args:
            prompt: The prompt to send
            model: Model to use
            temperature: Sampling temperature (0-1)
            working_dir: Working directory for code execution
            action_mode: Action mode (full-auto, interactive, review)
            auto_approve: Auto-approve all actions
        """
        options = CodexOptions(
            model=model,
            temperature=temperature,
            working_dir=Path(working_dir) if working_dir else None,
            action_mode=action_mode,
            auto_approve_everything=auto_approve,
            verbose=self.config.verbose,
        )

        try:
            asyncio.run(self._stream_async(prompt, options))
        except KeyboardInterrupt:
            console.print("\n[yellow]Stream interrupted[/yellow]")
        except Exception as e:
            console.print(f"[red]Error: {e}[/red]")
            if self.config.verbose:
                console.print_exception()
            sys.exit(1)

    async def _stream_async(self, prompt: str, options: CodexOptions) -> None:
        """Stream responses with live display."""
        content_buffer = []

        with Live(console=console, refresh_per_second=10) as live:
            async for message in query(prompt, options):
                # Update live display
                if isinstance(message.content, str):
                    content_buffer.append(message.content)
                elif isinstance(message.content, list):
                    for block in message.content:
                        if hasattr(block, "text"):
                            content_buffer.append(block.text)

                live.update("".join(content_buffer))

    def models(self) -> None:
        """List available Codex models."""
        console.print("[bold]Available Codex Models:[/bold]")

        models = [
            ("o4-mini", "Optimized for speed and efficiency (default)"),
            ("o4", "Balanced performance and capability"),
            ("o4-preview", "Latest features, may be unstable"),
            ("o3.5", "Previous generation, stable"),
        ]

        table = Table(show_header=True, header_style="bold cyan")
        table.add_column("Model", style="green")
        table.add_column("Description")

        for model, desc in models:
            table.add_row(model, desc)

        console.print(table)

    def health(self) -> None:
        """Check Codex service health."""
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                transient=True,
            ) as progress:
                task = progress.add_task("Checking Codex health...", total=None)

                # Simple health check
                result = asyncio.run(self._health_check())
                progress.update(task, completed=True)

            if result:
                console.print("[green]✓ Codex service is healthy[/green]")
            else:
                console.print("[red]✗ Codex service is not responding[/red]")
                sys.exit(1)

        except Exception as e:
            console.print(f"[red]Health check failed: {e}[/red]")
            sys.exit(1)

    async def _health_check(self) -> bool:
        """Perform health check."""
        try:
            options = CodexOptions(
                timeout=10,
                max_tokens=10,
                action_mode="review",
            )
            message_count = 0

            async for _ in query("Hello", options):
                message_count += 1
                if message_count > 0:
                    return True

            return message_count > 0
        except Exception:
            return False

    def config(self, action: str = "show", **kwargs) -> None:
        """Manage Codex configuration.

        Args:
            action: Action to perform (show, set)
            **kwargs: Configuration values for 'set' action
        """
        if action == "show":
            console.print("[bold]Codex Configuration:[/bold]")
            codex_config = self.config.providers.get(Provider.CODEX, {})

            if isinstance(codex_config, dict):
                for key, value in codex_config.items():
                    console.print(f"  {key}: {value}")
            else:
                console.print(f"  enabled: {codex_config.enabled}")
                console.print(f"  model: {codex_config.model}")
                console.print(f"  timeout: {codex_config.timeout}")

            # Show environment variables
            console.print("\n[bold]Environment:[/bold]")
            console.print(f"  CODEX_CLI_PATH: {os.environ.get('CODEX_CLI_PATH', 'Not set')}")

        elif action == "set":
            if not kwargs:
                console.print("[red]No configuration values provided[/red]")
                return

            # Update configuration
            for key, value in kwargs.items():
                console.print(f"[green]Set {key} = {value}[/green]")

            console.print(
                "\n[yellow]Note: Configuration changes are temporary. Update config file for persistence.[/yellow]"
            )

        else:
            console.print(f"[red]Unknown action: {action}[/red]")
            console.print("Available actions: show, set")

    def modes(self) -> None:
        """Show available action modes."""
        console.print("[bold]Codex Action Modes:[/bold]")

        modes = [
            ("review", "Review each action before execution (default)"),
            ("interactive", "Interactive mode with prompts"),
            ("full-auto", "Fully automatic execution (use with caution)"),
        ]

        table = Table(show_header=True, header_style="bold cyan")
        table.add_column("Mode", style="green")
        table.add_column("Description")

        for mode, desc in modes:
            table.add_row(mode, desc)

        console.print(table)
        console.print("\n[yellow]Tip: Use --action-mode <mode> to set the mode[/yellow]")


def main():
    """Main entry point for Fire CLI."""
    fire.Fire(CodexCLI)
</file>

<file path="src/claif_cod/client.py">
"""Client implementation for Codex."""

from typing import Optional
from collections.abc import AsyncIterator

from claif.common import Message, get_logger
from .types import CodexOptions, CodexMessage, ResultMessage
from .transport import CodexTransport


logger = get_logger(__name__)


class CodexClient:
    """Client for interacting with Codex."""

    def __init__(self):
        self.transport = CodexTransport()

    async def query(
        self,
        prompt: str,
        options: CodexOptions | None = None,
    ) -> AsyncIterator[Message]:
        """Query Codex and yield messages."""
        if options is None:
            options = CodexOptions()

        logger.debug(f"Querying Codex with prompt: {prompt[:100]}...")
        logger.debug(f"Using model: {options.model}")

        try:
            await self.transport.connect()

            async for response in self.transport.send_query(prompt, options):
                if isinstance(response, CodexMessage):
                    yield response.to_claif_message()
                elif isinstance(response, ResultMessage) and response.error:
                    logger.error(f"Codex error: {response.message}")
                    raise Exception(response.message)

        finally:
            await self.transport.disconnect()


# Module-level client instance
_client = CodexClient()


async def query(
    prompt: str,
    options: CodexOptions | None = None,
) -> AsyncIterator[Message]:
    """Query Codex using the default client."""
    async for message in _client.query(prompt, options):
        yield message
</file>

<file path="src/claif_cod/transport.py">
"""Transport layer for Codex CLI communication."""

import json
import os
import shutil
import sys
import uuid
from pathlib import Path
from typing import Optional, List, Union, Dict, Any
from collections.abc import AsyncIterator

import anyio
from anyio.streams.text import TextReceiveStream

from claif.common import get_logger, TransportError
from .types import (
    CodexOptions,
    CodexMessage,
    ResultMessage,
    TextBlock,
    CodeBlock,
    ErrorBlock,
    ContentBlock,
)


logger = get_logger(__name__)


class CodexTransport:
    """Transport for communicating with Codex CLI."""

    def __init__(self):
        self.process: anyio.Process | None = None
        self.session_id = str(uuid.uuid4())

    async def connect(self) -> None:
        """Initialize transport (no-op for subprocess)."""
        pass

    async def disconnect(self) -> None:
        """Cleanup transport."""
        if self.process:
            try:
                self.process.terminate()
                await self.process.wait()
            except Exception as e:
                logger.warning(f"Error during disconnect: {e}")
            finally:
                self.process = None

    async def send_query(self, prompt: str, options: CodexOptions) -> AsyncIterator[CodexMessage | ResultMessage]:
        """Send query to Codex and yield responses."""
        command = self._build_command(prompt, options)
        env = self._build_env()
        cwd = options.working_dir or options.cwd

        if options.verbose:
            logger.debug(f"Running command: {' '.join(command)}")
            logger.debug(f"Working directory: {cwd}")

        try:
            start_time = anyio.current_time()

            async with await anyio.open_process(
                command,
                env=env,
                cwd=cwd,
                stdout=anyio.subprocess.PIPE,
                stderr=anyio.subprocess.PIPE,
            ) as process:
                self.process = process

                # Read output line by line for streaming JSON
                stdout_stream = TextReceiveStream(process.stdout)
                stderr_lines = []

                # Collect stderr in background
                async def read_stderr():
                    stderr_stream = TextReceiveStream(process.stderr)
                    async for line in stderr_stream:
                        stderr_lines.append(line)

                async with anyio.create_task_group() as tg:
                    tg.start_soon(read_stderr)

                    # Process stdout line by line
                    async for line in stdout_stream:
                        line = line.strip()
                        if not line:
                            continue

                        try:
                            data = json.loads(line)
                            message = self._parse_message(data)
                            if message:
                                yield message
                        except json.JSONDecodeError as e:
                            logger.warning(f"Failed to parse JSON line: {e}")
                            logger.debug(f"Raw line: {line}")

                # Wait for process to complete
                await process.wait()

                duration = anyio.current_time() - start_time

                # Check for errors
                if process.returncode != 0:
                    error_msg = "".join(stderr_lines) or "Unknown error"
                    yield ResultMessage(
                        error=True,
                        message=f"Codex CLI error: {error_msg}",
                        duration=duration,
                        session_id=self.session_id,
                        model=options.model,
                    )
                else:
                    # Send success result message
                    yield ResultMessage(
                        duration=duration,
                        session_id=self.session_id,
                        model=options.model,
                    )

        except Exception as e:
            logger.error(f"Transport error: {e}")
            yield ResultMessage(
                error=True,
                message=str(e),
                session_id=self.session_id,
                model=options.model,
            )

    def _parse_message(self, data: dict[str, Any]) -> CodexMessage | ResultMessage | None:
        """Parse a JSON message into appropriate type."""
        msg_type = data.get("type")

        if msg_type == "result":
            return ResultMessage(
                type="result",
                duration=data.get("duration"),
                error=data.get("error", False),
                message=data.get("message"),
                session_id=data.get("session_id"),
                model=data.get("model"),
                token_count=data.get("token_count"),
            )

        # Parse as CodexMessage
        role = data.get("role", "assistant")
        content = data.get("content", [])

        if isinstance(content, str):
            # Handle plain string content
            content_blocks = [TextBlock(text=content)]
        else:
            # Parse content blocks
            content_blocks = []
            for block in content:
                block_type = block.get("type")

                if block_type == "output_text":
                    content_blocks.append(
                        TextBlock(
                            type=block_type,
                            text=block.get("text", ""),
                        )
                    )
                elif block_type == "code":
                    content_blocks.append(
                        CodeBlock(
                            type=block_type,
                            language=block.get("language", ""),
                            content=block.get("content", ""),
                        )
                    )
                elif block_type == "error":
                    content_blocks.append(
                        ErrorBlock(
                            type=block_type,
                            error_message=block.get("error_message", ""),
                        )
                    )
                else:
                    # Unknown block type - treat as text
                    logger.warning(f"Unknown block type: {block_type}")
                    content_blocks.append(
                        TextBlock(
                            text=str(block),
                        )
                    )

        return CodexMessage(role=role, content=content_blocks)

    def _build_command(self, prompt: str, options: CodexOptions) -> list[str]:
        """Build command line arguments."""
        cli_path = self._find_cli()
        command = [cli_path]

        # Model
        command.extend(["-m", options.model])

        # Working directory
        if options.working_dir:
            command.extend(["-w", str(options.working_dir)])

        # Action mode
        command.extend(["-a", options.action_mode])

        # Auto-approve
        if options.auto_approve_everything:
            command.append("--auto-approve")

        # Full auto
        if options.full_auto:
            command.append("--full-auto")

        # Optional parameters
        if options.temperature is not None:
            command.extend(["--temperature", str(options.temperature)])

        if options.max_tokens is not None:
            command.extend(["--max-tokens", str(options.max_tokens)])

        if options.top_p is not None:
            command.extend(["--top-p", str(options.top_p)])

        # JSON output format
        command.extend(["--output-format", "json"])

        # Query/prompt
        command.extend(["-q", prompt])

        return command

    def _build_env(self) -> dict:
        """Build environment variables."""
        env = os.environ.copy()
        env["CODEX_SDK"] = "1"
        env["CLAIF_PROVIDER"] = "codex"
        return env

    def _find_cli(self) -> str:
        """Find Codex CLI executable."""
        # Check if specified in environment
        if cli_path := os.environ.get("CODEX_CLI_PATH"):
            if Path(cli_path).exists():
                return cli_path

        # Search in PATH
        if cli := shutil.which("codex"):
            return cli

        # Search common locations
        search_paths = [
            Path.home() / ".local" / "bin" / "codex",
            Path("/usr/local/bin/codex"),
            Path("/opt/codex/bin/codex"),
        ]

        # Add platform-specific paths
        if sys.platform == "darwin":
            search_paths.append(Path("/opt/homebrew/bin/codex"))
        elif sys.platform == "win32":
            search_paths.extend(
                [
                    Path("C:/Program Files/Codex/codex.exe"),
                    Path(os.environ.get("LOCALAPPDATA", "")) / "Programs" / "codex" / "codex.exe",
                ]
            )

        for path in search_paths:
            if path.exists():
                return str(path)

        raise TransportError("Codex CLI not found. Please install it or set CODEX_CLI_PATH environment variable.")
</file>

<file path="src/claif_cod/types.py">
"""Type definitions for CLAIF Codex wrapper."""

from dataclasses import dataclass
from pathlib import Path
from typing import Optional, Union, List, Any

from claif.common import Message, MessageRole, TextBlock as ClaifTextBlock


@dataclass
class TextBlock:
    """Text output block."""

    type: str = "output_text"
    text: str = ""


@dataclass
class CodeBlock:
    """Code output block."""

    type: str = "code"
    language: str = ""
    content: str = ""


@dataclass
class ErrorBlock:
    """Error output block."""

    type: str = "error"
    error_message: str = ""


ContentBlock = Union[TextBlock, CodeBlock, ErrorBlock]


@dataclass
class CodexOptions:
    """Options for Codex queries."""

    model: str = "o4-mini"
    auto_approve_everything: bool = False
    full_auto: bool = False
    action_mode: str = "review"  # "full-auto", "interactive", or "review"
    working_dir: str | Path | None = None
    cwd: str | Path | None = None  # Alias for working_dir
    temperature: float | None = None
    max_tokens: int | None = None
    top_p: float | None = None
    timeout: int | None = None
    verbose: bool = False

    def __post_init__(self):
        # Handle cwd alias
        if self.cwd and not self.working_dir:
            self.working_dir = self.cwd


@dataclass
class CodexMessage:
    """A message from Codex."""

    role: str
    content: list[ContentBlock]

    def to_claif_message(self) -> Message:
        """Convert to CLAIF message."""
        # Convert content blocks to text
        text_parts = []
        for block in self.content:
            if isinstance(block, TextBlock):
                text_parts.append(block.text)
            elif isinstance(block, CodeBlock):
                text_parts.append(f"```{block.language}\n{block.content}\n```")
            elif isinstance(block, ErrorBlock):
                text_parts.append(f"Error: {block.error_message}")

        content = "\n".join(text_parts) if text_parts else ""

        role = MessageRole.ASSISTANT if self.role == "assistant" else MessageRole.USER
        return Message(role=role, content=content)


@dataclass
class ResultMessage:
    """Result message with metadata."""

    type: str = "result"
    duration: float | None = None
    error: bool = False
    message: str | None = None
    session_id: str | None = None
    model: str | None = None
    token_count: int | None = None
</file>

<file path="tests/test_package.py">
"""Test suite for claif_cod."""


def test_version():
    """Verify package exposes version."""
    import claif_cod

    assert claif_cod.__version__
</file>

<file path=".gitignore">
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private
VERSION.txt
</file>

<file path=".pre-commit-config.yaml">
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
</file>

<file path="AGENTS.md">
# CLAIF (Command-Line Artificial Intelligence Framework)

CLAIF (Command-Line AI Framework) is a unified interface for interacting with various large language models (LLMs) from the command line.

The project consists of four Github repositories and Python packages:

- [`claif_cla`](https://github.com/twardoch/claif_cla/): CLI and Python package that wraps the [`claude_code_sdk`](https://github.com/anthropics/claude-code-sdk-python) package for interacting with Anthropic’s [Claude Code CLI](https://github.com/anthropics/claude-code) agentic CLI toolkit based on their Claude models.
- [`claif_cod`](https://github.com/twardoch/claif_cod/): CLI and Python package for interacting with OpenAI’s new [Codex CLI](https://github.com/openai/codex) agentic CLI toolkit based on OpenAI’s models.
- [`claif_gem`](https://github.com/twardoch/claif_gem/): CLI and Python package for that wraps the [Gemini CLI](https://github.com/google-gemini/gemini-cli/) agentic CLI toolkit based on Google’s Gemini models.
- [`claif`](https://github.com/twardoch/claif/): The top-level CLAIF framework that provides the main building blocks, including the client, server, and provider integrations.

This document provides comprehensive development guidelines for all packages in the CLAIF ecosystem.

## 1. This very project overview

### 1.1. `claif_cod`: CLAIF provider for the OpenAI Codex CLI toolkit

[`claif_cod`](https://github.com/twardoch/claif_cod/): CLI and Python package for interacting with OpenAI’s new [Codex CLI](https://github.com/openai/codex) agentic CLI toolkit based on OpenAI’s models.

**Key Responsibilities:**

- Code generation and manipulation
- Action mode management (review/interactive/auto)
- Working directory integration
- Project-aware operations

**Development Focus:**

- Code safety and review features
- File system operations
- Project context awareness
- Action mode refinement

## 2. Other projects in the CLAIF ecosystem

### 2.1. `claif`: CLAIF core framework

[`claif`](https://github.com/twardoch/claif/) is the top-level CLAIF framework that provides the main building blocks, including the client, server, and provider integrations.

**Key Responsibilities:**

- Provider abstraction and routing
- Plugin discovery and loading
- Common types and error handling
- Configuration management
- CLI framework (Fire-based)
- MCP server implementation

**Development Focus:**

- Maintain strict API compatibility
- Ensure provider independence
- Keep dependencies minimal
- Prioritize extensibility

### 2.2. `claif_cla`: CLAIF provider for the Anthropic Claude Code CLI toolkit

[`claif_cla`](https://github.com/twardoch/claif_cla/) is a CLI and Python package that wraps the [`claude_code_sdk`](https://github.com/anthropics/claude-code-sdk-python) package for interacting with Anthropic’s [Claude Code CLI](https://github.com/anthropics/claude-code) agentic CLI toolkit based on their Claude models.

**Key Responsibilities:**

- Claude API integration
- Session management and persistence
- Tool approval strategies
- Response caching
- Session branching/merging

**Development Focus:**

- Maintain claude-code-sdk compatibility
- Enhance session features
- Improve approval strategies
- Optimize caching logic

### 2.3. `claif_gem`: CLAIF provider for the Google Gemini CLI toolkit

[`claif_gem`](https://github.com/twardoch/claif_gem/): CLI and Python package for that wraps the [Gemini CLI](https://github.com/google-gemini/gemini-cli/) agentic CLI toolkit based on Google’s Gemini models.

**Key Responsibilities:**

- Gemini CLI subprocess management
- Auto-approval and yes-mode handling
- Context length management
- System prompt configuration

**Development Focus:**

- Robust subprocess handling
- CLI argument parsing
- Timeout and error recovery
- Cross-platform compatibility

## 3. Working Principles for CLAIF Development

### 3.1. Core Development Principles

When developing for CLAIF (in any sub-project):

- **Iterate gradually**, avoiding major breaking changes to the plugin interface
- **Minimize user confirmations** while maintaining safety, especially for code operations
- **Preserve existing API contracts** unless a major version bump is planned
- **Use module-level constants** over magic numbers (e.g., `DEFAULT_TIMEOUT = 120`)
- **Check for existing utilities** in `claif.common` before implementing new ones
- **Ensure coherence** between provider implementations and the unified interface
- **Focus on minimal viable features** and ship incremental improvements
- **Write comprehensive docstrings** explaining both what and WHY, including cross-references
- **Analyze provider differences** line-by-line when implementing unified features
- **Handle provider failures gracefully** with retries, fallbacks, and clear error messages
- **Address edge cases** like network timeouts, API limits, and malformed responses
- **Let the framework handle complexity**, minimize provider-specific user decisions
- **Reduce cognitive load** through consistent naming and behavior across providers
- **Modularize provider logic** into focused, testable components
- **Favor flat provider hierarchies** over deeply nested inheritance
- **Maintain documentation**:
  - README.md (purpose and usage for each sub-project)
  - CHANGELOG.md (version history with migration notes)
  - TODO.md (planned features and known issues)
  - PROGRESS.md (implementation status for each provider)

### 3.2. Using Development Tools

Before and during development, you should:

- Use `context7` tool to check latest Python package documentation
- Consult `deepseek/deepseek-r1-0528:free` via `chat_completion` for complex architectural decisions
- Query `openai/o3` via `chat_completion` for API design and compatibility questions
- Apply `sequentialthinking` tool for solving cross-provider compatibility issues
- Search with `perplexity_ask` and `duckduckgo_web_search` for provider API updates

### 3.3. File Organization

In each source file, maintain the `this_file` record:

```python
# this_file: src/claif_cla/cli.py
"""CLI interface for the CLAIF Claude provider"""
```

### 3.4. Python-Specific Guidelines

For all CLAIF Python code:

- **PEP 8**: Consistent formatting with 120-char line limit (per pyproject.toml)
- **Descriptive names**: `query_with_retry()` not `qwr()`
- **PEP 20**: Explicit provider selection over magic
- **Type hints**: Use simple unions (`str | None` not `Optional[str]`)
- **PEP 257**: Imperative mood docstrings with provider examples
- **Modern Python**: f-strings, pattern matching for message types
- **Logging**: Loguru-based with provider-specific contexts
- **CLI scripts**: Fire & rich with uv shebang:

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["fire", "rich", "claif"]
# ///
# this_file: scripts/provider_test.py
```

After changes, run:

```bash
uv run uzpy run .
fd -e py -x autoflake {}
fd -e py -x pyupgrade --py312-plus {}
fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x ruff format --respect-gitignore --target-version py312 {}
python -m pytest
```

## 4. Sub-Project Specific Guidelines

### 4.1. `claif_cod`: CLAIF provider for the OpenAI Codex CLI toolkit

**Code Safety:**

- Default to review mode for all operations
- Implement diff preview before applying changes
- Maintain operation history for rollback

**Project Integration:**

- Respect .gitignore patterns
- Detect project type (Python, JS, etc.)
- Use appropriate code formatters

**Action Modes:**

- Clearly separate mode logic
- Provide mode transition safeguards
- Log all automated actions

## 5. Quality Assurance

### 5.1. Pre-Commit Checks

All sub-projects must pass:

```yaml
- repo: https://github.com/astral-sh/ruff-pre-commit
  hooks:
    - id: ruff
    - id: ruff-format
- repo: https://github.com/pre-commit/mirrors-mypy
  hooks:
    - id: mypy
```

### 5.2. Testing Strategy

1. **Unit Tests**: Provider-specific logic
2. **Integration Tests**: Provider + CLAIF core
3. **E2E Tests**: CLI commands with real providers
4. **Performance Tests**: Response time, memory usage

### 5.3. Documentation Requirements

Each sub-project must maintain:

- Comprehensive README with examples
- API reference (autodoc where possible)
- Migration guides for breaking changes
- Troubleshooting section

## 6. Virtual Team Collaboration

When developing CLAIF:

**Be creative, diligent, critical, relentless & funny!**

Lead two virtual experts:

- **"Ideot"**: Proposes creative provider features and unconventional integrations
- **"Critin"**: Critiques API design and identifies compatibility issues

The three of you shall:

- Illuminate the best provider abstraction patterns
- Process provider differences methodically
- Collaborate on cross-provider features
- Adapt when provider APIs change

If compatibility issues arise, step back and focus on the unified interface goals.

## 7. Release Coordination

Since CLAIF uses a monorepo structure:

1. Version all packages together
2. Update inter-package dependencies
3. Test all providers before release
4. Publish in order: claif → providers
5. Tag releases with `v{version}`

## 8. Final Checkpoint

When completing any CLAIF development:

**"Wait, but..."** - Review your changes:

- Does it maintain provider abstraction?
- Is the API still unified?
- Are errors handled consistently?
- Is the documentation updated?

Repeat this reflection, but stick to "minimal viable next version" philosophy.

Remember: CLAIF's strength is its unified interface. Every line of code should serve this goal while allowing providers to shine with their unique capabilities.
</file>

<file path="GEMINI.md">
# CLAIF (Command-Line Artificial Intelligence Framework)

CLAIF (Command-Line AI Framework) is a unified interface for interacting with various large language models (LLMs) from the command line.

The project consists of four Github repositories and Python packages:

- [`claif_cla`](https://github.com/twardoch/claif_cla/): CLI and Python package that wraps the [`claude_code_sdk`](https://github.com/anthropics/claude-code-sdk-python) package for interacting with Anthropic’s [Claude Code CLI](https://github.com/anthropics/claude-code) agentic CLI toolkit based on their Claude models.
- [`claif_cod`](https://github.com/twardoch/claif_cod/): CLI and Python package for interacting with OpenAI’s new [Codex CLI](https://github.com/openai/codex) agentic CLI toolkit based on OpenAI’s models.
- [`claif_gem`](https://github.com/twardoch/claif_gem/): CLI and Python package for that wraps the [Gemini CLI](https://github.com/google-gemini/gemini-cli/) agentic CLI toolkit based on Google’s Gemini models.
- [`claif`](https://github.com/twardoch/claif/): The top-level CLAIF framework that provides the main building blocks, including the client, server, and provider integrations.

This document provides comprehensive development guidelines for all packages in the CLAIF ecosystem.

## 1. This very project overview

### 1.1. `claif_cod`: CLAIF provider for the OpenAI Codex CLI toolkit

[`claif_cod`](https://github.com/twardoch/claif_cod/): CLI and Python package for interacting with OpenAI’s new [Codex CLI](https://github.com/openai/codex) agentic CLI toolkit based on OpenAI’s models.

**Key Responsibilities:**

- Code generation and manipulation
- Action mode management (review/interactive/auto)
- Working directory integration
- Project-aware operations

**Development Focus:**

- Code safety and review features
- File system operations
- Project context awareness
- Action mode refinement

## 2. Other projects in the CLAIF ecosystem

### 2.1. `claif`: CLAIF core framework

[`claif`](https://github.com/twardoch/claif/) is the top-level CLAIF framework that provides the main building blocks, including the client, server, and provider integrations.

**Key Responsibilities:**

- Provider abstraction and routing
- Plugin discovery and loading
- Common types and error handling
- Configuration management
- CLI framework (Fire-based)
- MCP server implementation

**Development Focus:**

- Maintain strict API compatibility
- Ensure provider independence
- Keep dependencies minimal
- Prioritize extensibility

### 2.2. `claif_cla`: CLAIF provider for the Anthropic Claude Code CLI toolkit

[`claif_cla`](https://github.com/twardoch/claif_cla/) is a CLI and Python package that wraps the [`claude_code_sdk`](https://github.com/anthropics/claude-code-sdk-python) package for interacting with Anthropic’s [Claude Code CLI](https://github.com/anthropics/claude-code) agentic CLI toolkit based on their Claude models.

**Key Responsibilities:**

- Claude API integration
- Session management and persistence
- Tool approval strategies
- Response caching
- Session branching/merging

**Development Focus:**

- Maintain claude-code-sdk compatibility
- Enhance session features
- Improve approval strategies
- Optimize caching logic

### 2.3. `claif_gem`: CLAIF provider for the Google Gemini CLI toolkit

[`claif_gem`](https://github.com/twardoch/claif_gem/): CLI and Python package for that wraps the [Gemini CLI](https://github.com/google-gemini/gemini-cli/) agentic CLI toolkit based on Google’s Gemini models.

**Key Responsibilities:**

- Gemini CLI subprocess management
- Auto-approval and yes-mode handling
- Context length management
- System prompt configuration

**Development Focus:**

- Robust subprocess handling
- CLI argument parsing
- Timeout and error recovery
- Cross-platform compatibility

## 3. Working Principles for CLAIF Development

### 3.1. Core Development Principles

When developing for CLAIF (in any sub-project):

- **Iterate gradually**, avoiding major breaking changes to the plugin interface
- **Minimize user confirmations** while maintaining safety, especially for code operations
- **Preserve existing API contracts** unless a major version bump is planned
- **Use module-level constants** over magic numbers (e.g., `DEFAULT_TIMEOUT = 120`)
- **Check for existing utilities** in `claif.common` before implementing new ones
- **Ensure coherence** between provider implementations and the unified interface
- **Focus on minimal viable features** and ship incremental improvements
- **Write comprehensive docstrings** explaining both what and WHY, including cross-references
- **Analyze provider differences** line-by-line when implementing unified features
- **Handle provider failures gracefully** with retries, fallbacks, and clear error messages
- **Address edge cases** like network timeouts, API limits, and malformed responses
- **Let the framework handle complexity**, minimize provider-specific user decisions
- **Reduce cognitive load** through consistent naming and behavior across providers
- **Modularize provider logic** into focused, testable components
- **Favor flat provider hierarchies** over deeply nested inheritance
- **Maintain documentation**:
  - README.md (purpose and usage for each sub-project)
  - CHANGELOG.md (version history with migration notes)
  - TODO.md (planned features and known issues)
  - PROGRESS.md (implementation status for each provider)

### 3.2. Using Development Tools

Before and during development, you should:

- Use `context7` tool to check latest Python package documentation
- Consult `deepseek/deepseek-r1-0528:free` via `chat_completion` for complex architectural decisions
- Query `openai/o3` via `chat_completion` for API design and compatibility questions
- Apply `sequentialthinking` tool for solving cross-provider compatibility issues
- Search with `perplexity_ask` and `duckduckgo_web_search` for provider API updates

### 3.3. File Organization

In each source file, maintain the `this_file` record:

```python
# this_file: src/claif_cla/cli.py
"""CLI interface for the CLAIF Claude provider"""
```

### 3.4. Python-Specific Guidelines

For all CLAIF Python code:

- **PEP 8**: Consistent formatting with 120-char line limit (per pyproject.toml)
- **Descriptive names**: `query_with_retry()` not `qwr()`
- **PEP 20**: Explicit provider selection over magic
- **Type hints**: Use simple unions (`str | None` not `Optional[str]`)
- **PEP 257**: Imperative mood docstrings with provider examples
- **Modern Python**: f-strings, pattern matching for message types
- **Logging**: Loguru-based with provider-specific contexts
- **CLI scripts**: Fire & rich with uv shebang:

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["fire", "rich", "claif"]
# ///
# this_file: scripts/provider_test.py
```

After changes, run:

```bash
uv run uzpy run .
fd -e py -x autoflake {}
fd -e py -x pyupgrade --py312-plus {}
fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x ruff format --respect-gitignore --target-version py312 {}
python -m pytest
```

## 4. Sub-Project Specific Guidelines

### 4.1. `claif_cod`: CLAIF provider for the OpenAI Codex CLI toolkit

**Code Safety:**

- Default to review mode for all operations
- Implement diff preview before applying changes
- Maintain operation history for rollback

**Project Integration:**

- Respect .gitignore patterns
- Detect project type (Python, JS, etc.)
- Use appropriate code formatters

**Action Modes:**

- Clearly separate mode logic
- Provide mode transition safeguards
- Log all automated actions

## 5. Quality Assurance

### 5.1. Pre-Commit Checks

All sub-projects must pass:

```yaml
- repo: https://github.com/astral-sh/ruff-pre-commit
  hooks:
    - id: ruff
    - id: ruff-format
- repo: https://github.com/pre-commit/mirrors-mypy
  hooks:
    - id: mypy
```

### 5.2. Testing Strategy

1. **Unit Tests**: Provider-specific logic
2. **Integration Tests**: Provider + CLAIF core
3. **E2E Tests**: CLI commands with real providers
4. **Performance Tests**: Response time, memory usage

### 5.3. Documentation Requirements

Each sub-project must maintain:

- Comprehensive README with examples
- API reference (autodoc where possible)
- Migration guides for breaking changes
- Troubleshooting section

## 6. Virtual Team Collaboration

When developing CLAIF:

**Be creative, diligent, critical, relentless & funny!**

Lead two virtual experts:

- **"Ideot"**: Proposes creative provider features and unconventional integrations
- **"Critin"**: Critiques API design and identifies compatibility issues

The three of you shall:

- Illuminate the best provider abstraction patterns
- Process provider differences methodically
- Collaborate on cross-provider features
- Adapt when provider APIs change

If compatibility issues arise, step back and focus on the unified interface goals.

## 7. Release Coordination

Since CLAIF uses a monorepo structure:

1. Version all packages together
2. Update inter-package dependencies
3. Test all providers before release
4. Publish in order: claif → providers
5. Tag releases with `v{version}`

## 8. Final Checkpoint

When completing any CLAIF development:

**"Wait, but..."** - Review your changes:

- Does it maintain provider abstraction?
- Is the API still unified?
- Are errors handled consistently?
- Is the documentation updated?

Repeat this reflection, but stick to "minimal viable next version" philosophy.

Remember: CLAIF's strength is its unified interface. Every line of code should serve this goal while allowing providers to shine with their unique capabilities.
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="pyproject.toml">
# this_file: pyproject.toml
#==============================================================================
# CLAIF_COD PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the claif_cod package.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = 'claif_cod' # Package name on PyPI
description = 'Codex provider for CLAIF - AI-powered code generation and manipulation through OpenAI Codex CLI' # Short description
readme = 'README.md' # Path to README file
requires-python = '>=3.10' # Minimum Python version
keywords = [
    'ai',
    'cli',
    'codex',
    'openai',
    'code-generation',
    'refactoring',
    'automation',
    'claif',
    'llm',
    'assistant',
] # Keywords for PyPI search
dynamic = ["version"] # Fields set dynamically at build time

# PyPI classifiers for package categorization
classifiers = [
    'Development Status :: 4 - Beta', # Package maturity level
    'Programming Language :: Python',
    'Programming Language :: Python :: 3.10',
    'Programming Language :: Python :: 3.11',
    'Programming Language :: Python :: 3.12',
    'Programming Language :: Python :: Implementation :: CPython',
    'Programming Language :: Python :: Implementation :: PyPy',
    'Operating System :: OS Independent',
    'License :: OSI Approved :: MIT License',
    'Intended Audience :: Developers',
]

dependencies = [
    "claif>=0.1.0",
    "anyio>=4.0.0",
    "fire>=0.6.0",
    "rich>=13.0.0",
    "loguru>=0.7.0",
]

# Author information
[[project.authors]]
name = 'Adam Twardoch'
email = 'adam+github@twardoch.com'

# License information
[project.license]
text = 'MIT'

# Project URLs
[project.urls]
Documentation = 'https://github.com/twardoch/claif_cod#readme'
Issues = 'https://github.com/twardoch/claif_cod/issues'
Source = 'https://github.com/twardoch/claif_cod'

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    'pre-commit>=4.1.0', # Pre-commit hook manager - Keep pre-commit as is, update if newer pre-commit version is required
    'ruff>=0.9.7', # Linting and formatting - Keep ruff as is, update if newer ruff version is required
    'mypy>=1.15.0', # Type checking - Keep mypy as is, update if newer mypy version is required
    'absolufy-imports>=0.3.1', # Convert relative imports to absolute - Keep absolufy-imports as is, update if newer absolufy-imports version is required
    'pyupgrade>=3.19.1', # Upgrade Python syntax - Keep pyupgrade as is, update if newer pyupgrade version is required
    'isort>=6.0.1', # Sort imports - Keep isort as is, update if newer isort version is required
]

# Testing tools and frameworks
test = [
    'pytest>=8.3.4', # Testing framework - Keep pytest as is, update if newer pytest version is required
    'pytest-cov>=6.0.0', # Coverage plugin for pytest - Keep pytest-cov as is, update if newer pytest-cov version is required
    'pytest-xdist>=3.6.1', # Parallel test execution - Keep pytest-xdist as is, update if newer pytest-xdist version is required
    'pytest-benchmark[histogram]>=5.1.0', # Benchmarking plugin - Keep pytest-benchmark as is, update if newer pytest-benchmark version is required
    'pytest-asyncio>=0.26.0', # Async test support - Keep pytest-asyncio as is, update if newer pytest-asyncio version is required
    'coverage[toml]>=7.6.12',
]

docs = [
    "sphinx>=8.2.3",
    "sphinx-rtd-theme>=3.0.2",
    "sphinx-autodoc-typehints>=3.2.0",
    "myst-parser>=4.0.1", # Markdown support in Sphinx
]

# All optional dependencies combined
all = [
    # Dev dependencies
    'pre-commit>=4.1.0',
    'ruff>=0.9.7',
    'mypy>=1.15.0',
    'absolufy-imports>=0.3.1',
    'pyupgrade>=3.19.1',
    'isort>=6.0.1',
    # Test dependencies
    'pytest>=8.3.4',
    'pytest-cov>=6.0.0',
    'pytest-xdist>=3.6.1',
    'pytest-benchmark[histogram]>=5.1.0',
    'pytest-asyncio>=0.25.3',
    'coverage[toml]>=7.6.12',
    # Docs dependencies
    "sphinx>=8.2.3",
    "sphinx-rtd-theme>=3.0.2",
    "sphinx-autodoc-typehints>=3.2.0",
    "myst-parser>=4.0.1", # Markdown support in Sphinx
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
claif-cod = "claif_cod.cli:main"

[project.entry-points."claif.plugins"]
cod = "claif_cod"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package and the build backend.
#------------------------------------------------------------------------------
[build-system]
# Hatchling is a modern build backend for Python packaging
# hatch-vcs integrates with version control systems for versioning
requires = [
    'hatchling>=1.27.0', # Keep hatchling as is, update if newer hatchling version is required
    'hatch-vcs>=0.4.0', # Keep hatch-vcs as is, update if newer hatch-vcs version is required
]
build-backend = 'hatchling.build' # Specifies Hatchling as the build backend


#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process, specifying which packages to include and
# how to handle versioning.
#------------------------------------------------------------------------------
[tool.hatch.build]
# Include package data files
include = [
    "src/claif_cod/*.py",
    "src/claif_cod/py.typed", # For better type checking support
]
exclude = [
    "**/__pycache__",
    "**/.pytest_cache",
    "**/.mypy_cache",
    "**/*.pyc",
    "**/*.pyo",
    "**/*~",
    "**/.DS_Store",
]

[tool.hatch.build.targets.wheel]
packages = ["src/claif_cod"]
reproducible = true
exclude = [
    "**/__pycache__",
    "**/*.pyc",
    "**/*.pyo",
]

[tool.hatch.build.targets.sdist]
include = [
    "src/",
    "tests/",
    "pyproject.toml",
    "README.md",
    "LICENSE",
    "CHANGELOG.md",
    "AGENTS.md",
    "CLAUDE.md",
    "GEMINI.md",
    ".cursorrules",
    ".gitignore",
    ".pre-commit-config.yaml",
]
exclude = [
    "**/__pycache__",
    "**/.pytest_cache",
    "**/.mypy_cache",
    "**/*.pyc",
    "**/*.pyo",
    "dist/",
    "build/",
    "*.egg-info/",
    ".git/",
    ".github/",
    "docs/build/",
    "htmlcov/",
    ".coverage*",
    "*.log",
]


# Version control system hook configuration
# Automatically updates the version file from git tags
[tool.hatch.build.hooks.vcs]
version-file = "src/claif_cod/__version__.py"

# Version source configuration
[tool.hatch.version]
source = 'vcs' # Get version from git tags or other VCS info

# Metadata handling configuration
[tool.hatch.metadata]
allow-direct-references = true # Allow direct references in metadata (useful for local dependencies)


#------------------------------------------------------------------------------
# DEVELOPMENT ENVIRONMENTS

[tool.hatch.envs.default]
features = ['dev', 'test', 'all']
dependencies = [
]

# Commands available in the default environment
[tool.hatch.envs.default.scripts]
# Run tests with optional arguments
test = 'pytest {args:tests}'
# Run tests with coverage reporting
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/claif_cod --cov=tests {args:tests}"
# Run type checking
type-check = "mypy src/claif_cod tests"
# Run linting and formatting
lint = ["ruff check src/claif_cod tests", "ruff format --respect-gitignore src/claif_cod tests"]
# Format and fix style issues
fmt = ["ruff format --respect-gitignore src/claif_cod tests", "ruff check --fix src/claif_cod tests"]
fix = ["ruff check --fix --unsafe-fixes src/claif_cod tests", "ruff format --respect-gitignore src/claif_cod tests"]

# Matrix configuration to test across multiple Python versions

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

#------------------------------------------------------------------------------
# SPECIALIZED ENVIRONMENTS
# Additional environments for specific development tasks.
#------------------------------------------------------------------------------

# Dedicated environment for linting and code quality checks
[tool.hatch.envs.lint]
detached = true # Create a separate, isolated environment
features = ['dev'] # Use dev extras  dependencies 

# Linting environment commands
[tool.hatch.envs.lint.scripts]
# Type checking with automatic type installation
typing = "mypy --install-types --non-interactive {args:src/claif_cod tests}"
# Check style and format code
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
# Format and fix style issues
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
fix = ["ruff check --fix --unsafe-fixes {args:.}", "ruff format --respect-gitignore {args:.}"]
# Run all ops
all = ["style", "typing", "fix"]

# Dedicated environment for testing
[tool.hatch.envs.test]
features = ['test'] # Use test extras as dependencies

# Testing environment commands
[tool.hatch.envs.test.scripts]
# Run tests in parallel
test = "python -m pytest -n auto {args:tests}"
# Run tests with coverage in parallel
test-cov = "python -m pytest -n auto --cov-report=term-missing --cov-config=pyproject.toml --cov=src/claif_cod --cov=tests {args:tests}"
# Run benchmarks
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
# Run benchmarks and save results
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ['docs']

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ['test']


[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/claif_cod --cov-report=xml"


#------------------------------------------------------------------------------
# CODE QUALITY TOOLS
# Configuration for linting, formatting, and code quality enforcement.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------

# Path mapping for coverage in different environments
[tool.coverage.paths]
claif_cod = ["src/claif_cod", "*/claif_cod/src/claif_cod"]
tests = ["tests", "*/claif_cod/tests"]

# Coverage report configuration
[tool.coverage.report]
# Lines to exclude from coverage reporting
exclude_lines = [
    'no cov', # Custom marker to skip coverage
    'if __name__ == .__main__.:', # Script execution guard
    'if TYPE_CHECKING:', # Type checking imports and code
    'pass', # Empty pass statements
    'raise NotImplementedError', # Unimplemented method placeholders
    'raise ImportError', # Import error handling
    'except ImportError', # Import error handling
    'except KeyError', # Common error handling
    'except AttributeError', # Common error handling
    'except NotImplementedError', # Common error handling
]

[tool.coverage.run]
source_pkgs = ["claif_cod", "tests"]
branch = true # Measure branch coverage (if/else statements)
parallel = true # Support parallel test execution
omit = [
    "src/claif_cod/__about__.py",
]

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[[tool.mypy.overrides]]
module = ["tests.*"]
disallow_untyped_defs = false
disallow_incomplete_defs = false

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest, including markers, options, and benchmark settings.
#------------------------------------------------------------------------------

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
asyncio_default_fixture_loop_scope = "function"
console_output_style = "progress"
filterwarnings = ["ignore::DeprecationWarning", "ignore::UserWarning"]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality", 
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing",
]
norecursedirs = [
    ".*",
    "build",
    "dist", 
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private",
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
]

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff, including linter and formatter settings.
#------------------------------------------------------------------------------ 

# Ruff linter and formatter configuration
[tool.ruff]
target-version = "py310"
line-length = 120
extend-exclude = [".git", ".venv", "venv", "dist", "build"]

# Linting rules configuration
[tool.ruff.lint]
# Rule sets to enable, organized by category
select = [
    # flake8 plugins and extensions
    'A', # flake8-builtins: checks for shadowed builtins
    'ARG', # flake8-unused-arguments: checks for unused function arguments
    'ASYNC', # flake8-async: checks for async/await issues
    'B', # flake8-bugbear: finds likely bugs and design problems
    'C', # flake8-comprehensions: helps write better list/dict comprehensions
    'DTZ', # flake8-datetimez: checks for datetime timezone issues
    'E', # pycodestyle errors: PEP 8 style guide errors
    'EM', # flake8-errmsg: checks for better error messages
    'F', # pyflakes: detects various errors
    'FBT', # flake8-boolean-trap: checks for boolean traps in function signatures
    'I', # isort: sorts imports
    'ICN', # flake8-import-conventions: checks for import conventions
    'ISC', # flake8-implicit-str-concat: checks for implicit string concatenation
    'LOG', # flake8-logging: checks for logging issues
    'N', # pep8-naming: checks naming conventions
    'PLC', # pylint convention: checks for convention issues
    'PLE', # pylint error: checks for errors
    'PLR', # pylint refactor: suggests refactors
    'PLW', # pylint warning: checks for suspicious code
    'PT', # flake8-pytest-style: checks pytest-specific style
    'PTH', # flake8-use-pathlib: checks for stdlib path usage vs pathlib
    'PYI', # flake8-pyi: checks stub files
    'RET', # flake8-return: checks return statement consistency
    'RSE', # flake8-raise: checks raise statements
    'RUF', # Ruff-specific rules
    'S', # flake8-bandit: checks for security issues
    'SIM', # flake8-simplify: checks for code simplification opportunities
    'T', # flake8-print: checks for print statements
    'TCH', # flake8-type-checking: helps with type-checking
    'TID', # flake8-tidy-imports: checks for tidy import statements
    'UP', # pyupgrade: checks for opportunities to use newer Python features
    'W', # pycodestyle warnings: PEP 8 style guide warnings
    'YTT', # flake8-2020: checks for misuse of sys.version or sys.version_info

]
# Rules to ignore (with reasons)
ignore = [
    'B027', # Empty method in abstract base class - sometimes needed for interfaces
    'C901', # Function is too complex - sometimes complexity is necessary
    'FBT003', # Boolean positional argument in function definition - sometimes unavoidable
    'PLR0911', # Too many return statements - sometimes needed for readability
    'PLR0912', # Too many branches - sometimes needed for complex logic
    'PLR0913', # Too many arguments - sometimes needed in APIs
    'PLR0915', # Too many statements - sometimes needed for comprehensive functions
    'PLR1714', # Consider merging multiple comparisons - sometimes less readable
    'PLW0603', # Using the global statement - sometimes necessary
    'PT013', # Pytest explicit test parameter - sometimes clearer
    'PTH123', # Path traversal - sometimes needed
    'PYI056', # Calling open() in pyi file - sometimes needed in type stubs
    'S105', # Possible hardcoded password - often false positives
    'S106', # Possible hardcoded password - often false positives
    'S107', # Possible hardcoded password - often false positives
    'S110', # try-except-pass - sometimes valid for suppressing exceptions
    'SIM102'
    # Nested if statements - sometimes more readable than combined conditions
]
# Rules that should not be automatically fixed
unfixable = [
    'F401', # Don't automatically remove unused imports - may be needed later

]

# isort configuration within Ruff
[tool.ruff.lint.isort]
known-first-party = ['claif_cod'] # Treat as first-party imports for sorting

# flake8-tidy-imports configuration within Ruff
[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = 'all' # Ban all relative imports for consistency

# Per-file rule exceptions
[tool.ruff.lint.per-file-ignores]
# Tests can use magic values, assertions, and relative imports
'tests/**/*' = [
    'PLR2004', # Allow magic values in tests for readability
    'S101', # Allow assertions in tests
    'TID252'
    # Allow relative imports in tests for convenience
]
</file>

<file path="src/claif_cod/__init__.py">
"""CLAIF Codex wrapper."""

from typing import Optional
from collections.abc import AsyncIterator

from claif.common import Message, ClaifOptions, get_logger
from .client import query as codex_query
from .types import CodexOptions


__version__ = "0.1.0"

logger = get_logger(__name__)


async def query(
    prompt: str,
    options: ClaifOptions | None = None,
) -> AsyncIterator[Message]:
    """Query Codex using CLAIF interface.

    Args:
        prompt: The prompt to send to Codex
        options: Optional CLAIF options

    Yields:
        Messages from Codex
    """
    if options is None:
        options = ClaifOptions()

    # Convert CLAIF options to Codex options
    codex_options = CodexOptions(
        model=options.model or "o4-mini",
        temperature=options.temperature,
        max_tokens=options.max_tokens,
        timeout=options.timeout,
        verbose=options.verbose,
    )

    logger.debug(f"Querying Codex with prompt: {prompt[:100]}...")

    # Pass through to Codex client
    async for message in codex_query(prompt, codex_options):
        yield message


__all__ = ["query", "CodexOptions"]
</file>

<file path=".cursorrules">
# CLAIF (Command-Line Artificial Intelligence Framework)

CLAIF (Command-Line AI Framework) is a unified interface for interacting with various large language models (LLMs) from the command line.

The project consists of four Github repositories and Python packages:

- [`claif_cla`](https://github.com/twardoch/claif_cla/): CLI and Python package that wraps the [`claude_code_sdk`](https://github.com/anthropics/claude-code-sdk-python) package for interacting with Anthropic’s [Claude Code CLI](https://github.com/anthropics/claude-code) agentic CLI toolkit based on their Claude models.
- [`claif_cod`](https://github.com/twardoch/claif_cod/): CLI and Python package for interacting with OpenAI’s new [Codex CLI](https://github.com/openai/codex) agentic CLI toolkit based on OpenAI’s models.
- [`claif_gem`](https://github.com/twardoch/claif_gem/): CLI and Python package for that wraps the [Gemini CLI](https://github.com/google-gemini/gemini-cli/) agentic CLI toolkit based on Google’s Gemini models.
- [`claif`](https://github.com/twardoch/claif/): The top-level CLAIF framework that provides the main building blocks, including the client, server, and provider integrations.

This document provides comprehensive development guidelines for all packages in the CLAIF ecosystem.

## 1. This very project overview

### 1.1. `claif_cod`: CLAIF provider for the OpenAI Codex CLI toolkit

[`claif_cod`](https://github.com/twardoch/claif_cod/): CLI and Python package for interacting with OpenAI’s new [Codex CLI](https://github.com/openai/codex) agentic CLI toolkit based on OpenAI’s models.

**Key Responsibilities:**

- Code generation and manipulation
- Action mode management (review/interactive/auto)
- Working directory integration
- Project-aware operations

**Development Focus:**

- Code safety and review features
- File system operations
- Project context awareness
- Action mode refinement

## 2. Other projects in the CLAIF ecosystem

### 2.1. `claif`: CLAIF core framework

[`claif`](https://github.com/twardoch/claif/) is the top-level CLAIF framework that provides the main building blocks, including the client, server, and provider integrations.

**Key Responsibilities:**

- Provider abstraction and routing
- Plugin discovery and loading
- Common types and error handling
- Configuration management
- CLI framework (Fire-based)
- MCP server implementation

**Development Focus:**

- Maintain strict API compatibility
- Ensure provider independence
- Keep dependencies minimal
- Prioritize extensibility

### 2.2. `claif_cla`: CLAIF provider for the Anthropic Claude Code CLI toolkit

[`claif_cla`](https://github.com/twardoch/claif_cla/) is a CLI and Python package that wraps the [`claude_code_sdk`](https://github.com/anthropics/claude-code-sdk-python) package for interacting with Anthropic’s [Claude Code CLI](https://github.com/anthropics/claude-code) agentic CLI toolkit based on their Claude models.

**Key Responsibilities:**

- Claude API integration
- Session management and persistence
- Tool approval strategies
- Response caching
- Session branching/merging

**Development Focus:**

- Maintain claude-code-sdk compatibility
- Enhance session features
- Improve approval strategies
- Optimize caching logic

### 2.3. `claif_gem`: CLAIF provider for the Google Gemini CLI toolkit

[`claif_gem`](https://github.com/twardoch/claif_gem/): CLI and Python package for that wraps the [Gemini CLI](https://github.com/google-gemini/gemini-cli/) agentic CLI toolkit based on Google’s Gemini models.

**Key Responsibilities:**

- Gemini CLI subprocess management
- Auto-approval and yes-mode handling
- Context length management
- System prompt configuration

**Development Focus:**

- Robust subprocess handling
- CLI argument parsing
- Timeout and error recovery
- Cross-platform compatibility

## 3. Working Principles for CLAIF Development

### 3.1. Core Development Principles

When developing for CLAIF (in any sub-project):

- **Iterate gradually**, avoiding major breaking changes to the plugin interface
- **Minimize user confirmations** while maintaining safety, especially for code operations
- **Preserve existing API contracts** unless a major version bump is planned
- **Use module-level constants** over magic numbers (e.g., `DEFAULT_TIMEOUT = 120`)
- **Check for existing utilities** in `claif.common` before implementing new ones
- **Ensure coherence** between provider implementations and the unified interface
- **Focus on minimal viable features** and ship incremental improvements
- **Write comprehensive docstrings** explaining both what and WHY, including cross-references
- **Analyze provider differences** line-by-line when implementing unified features
- **Handle provider failures gracefully** with retries, fallbacks, and clear error messages
- **Address edge cases** like network timeouts, API limits, and malformed responses
- **Let the framework handle complexity**, minimize provider-specific user decisions
- **Reduce cognitive load** through consistent naming and behavior across providers
- **Modularize provider logic** into focused, testable components
- **Favor flat provider hierarchies** over deeply nested inheritance
- **Maintain documentation**:
  - README.md (purpose and usage for each sub-project)
  - CHANGELOG.md (version history with migration notes)
  - TODO.md (planned features and known issues)
  - PROGRESS.md (implementation status for each provider)

### 3.2. Using Development Tools

Before and during development, you should:

- Use `context7` tool to check latest Python package documentation
- Consult `deepseek/deepseek-r1-0528:free` via `chat_completion` for complex architectural decisions
- Query `openai/o3` via `chat_completion` for API design and compatibility questions
- Apply `sequentialthinking` tool for solving cross-provider compatibility issues
- Search with `perplexity_ask` and `duckduckgo_web_search` for provider API updates

### 3.3. File Organization

In each source file, maintain the `this_file` record:

```python
# this_file: src/claif_cla/cli.py
"""CLI interface for the CLAIF Claude provider"""
```

### 3.4. Python-Specific Guidelines

For all CLAIF Python code:

- **PEP 8**: Consistent formatting with 120-char line limit (per pyproject.toml)
- **Descriptive names**: `query_with_retry()` not `qwr()`
- **PEP 20**: Explicit provider selection over magic
- **Type hints**: Use simple unions (`str | None` not `Optional[str]`)
- **PEP 257**: Imperative mood docstrings with provider examples
- **Modern Python**: f-strings, pattern matching for message types
- **Logging**: Loguru-based with provider-specific contexts
- **CLI scripts**: Fire & rich with uv shebang:

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["fire", "rich", "claif"]
# ///
# this_file: scripts/provider_test.py
```

After changes, run:

```bash
uv run uzpy run .
fd -e py -x autoflake {}
fd -e py -x pyupgrade --py312-plus {}
fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x ruff format --respect-gitignore --target-version py312 {}
python -m pytest
```

## 4. Sub-Project Specific Guidelines

### 4.1. `claif_cod`: CLAIF provider for the OpenAI Codex CLI toolkit

**Code Safety:**

- Default to review mode for all operations
- Implement diff preview before applying changes
- Maintain operation history for rollback

**Project Integration:**

- Respect .gitignore patterns
- Detect project type (Python, JS, etc.)
- Use appropriate code formatters

**Action Modes:**

- Clearly separate mode logic
- Provide mode transition safeguards
- Log all automated actions

## 5. Quality Assurance

### 5.1. Pre-Commit Checks

All sub-projects must pass:

```yaml
- repo: https://github.com/astral-sh/ruff-pre-commit
  hooks:
    - id: ruff
    - id: ruff-format
- repo: https://github.com/pre-commit/mirrors-mypy
  hooks:
    - id: mypy
```

### 5.2. Testing Strategy

1. **Unit Tests**: Provider-specific logic
2. **Integration Tests**: Provider + CLAIF core
3. **E2E Tests**: CLI commands with real providers
4. **Performance Tests**: Response time, memory usage

### 5.3. Documentation Requirements

Each sub-project must maintain:

- Comprehensive README with examples
- API reference (autodoc where possible)
- Migration guides for breaking changes
- Troubleshooting section

## 6. Virtual Team Collaboration

When developing CLAIF:

**Be creative, diligent, critical, relentless & funny!**

Lead two virtual experts:

- **"Ideot"**: Proposes creative provider features and unconventional integrations
- **"Critin"**: Critiques API design and identifies compatibility issues

The three of you shall:

- Illuminate the best provider abstraction patterns
- Process provider differences methodically
- Collaborate on cross-provider features
- Adapt when provider APIs change

If compatibility issues arise, step back and focus on the unified interface goals.

## 7. Release Coordination

Since CLAIF uses a monorepo structure:

1. Version all packages together
2. Update inter-package dependencies
3. Test all providers before release
4. Publish in order: claif → providers
5. Tag releases with `v{version}`

## 8. Final Checkpoint

When completing any CLAIF development:

**"Wait, but..."** - Review your changes:

- Does it maintain provider abstraction?
- Is the API still unified?
- Are errors handled consistently?
- Is the documentation updated?

Repeat this reflection, but stick to "minimal viable next version" philosophy.

Remember: CLAIF's strength is its unified interface. Every line of code should serve this goal while allowing providers to shine with their unique capabilities.
</file>

<file path="CLAUDE.md">
# CLAIF (Command-Line Artificial Intelligence Framework)

CLAIF (Command-Line AI Framework) is a unified interface for interacting with various large language models (LLMs) from the command line.

The project consists of four Github repositories and Python packages:

- [`claif_cla`](https://github.com/twardoch/claif_cla/): CLI and Python package that wraps the [`claude_code_sdk`](https://github.com/anthropics/claude-code-sdk-python) package for interacting with Anthropic’s [Claude Code CLI](https://github.com/anthropics/claude-code) agentic CLI toolkit based on their Claude models.
- [`claif_cod`](https://github.com/twardoch/claif_cod/): CLI and Python package for interacting with OpenAI’s new [Codex CLI](https://github.com/openai/codex) agentic CLI toolkit based on OpenAI’s models.
- [`claif_gem`](https://github.com/twardoch/claif_gem/): CLI and Python package for that wraps the [Gemini CLI](https://github.com/google-gemini/gemini-cli/) agentic CLI toolkit based on Google’s Gemini models.
- [`claif`](https://github.com/twardoch/claif/): The top-level CLAIF framework that provides the main building blocks, including the client, server, and provider integrations.

This document provides comprehensive development guidelines for all packages in the CLAIF ecosystem.

## 1. This very project overview

### 1.1. `claif_cod`: CLAIF provider for the OpenAI Codex CLI toolkit

[`claif_cod`](https://github.com/twardoch/claif_cod/): CLI and Python package for interacting with OpenAI’s new [Codex CLI](https://github.com/openai/codex) agentic CLI toolkit based on OpenAI’s models.

**Key Responsibilities:**

- Code generation and manipulation
- Action mode management (review/interactive/auto)
- Working directory integration
- Project-aware operations

**Development Focus:**

- Code safety and review features
- File system operations
- Project context awareness
- Action mode refinement

## 2. Other projects in the CLAIF ecosystem

### 2.1. `claif`: CLAIF core framework

[`claif`](https://github.com/twardoch/claif/) is the top-level CLAIF framework that provides the main building blocks, including the client, server, and provider integrations.

**Key Responsibilities:**

- Provider abstraction and routing
- Plugin discovery and loading
- Common types and error handling
- Configuration management
- CLI framework (Fire-based)
- MCP server implementation

**Development Focus:**

- Maintain strict API compatibility
- Ensure provider independence
- Keep dependencies minimal
- Prioritize extensibility

### 2.2. `claif_cla`: CLAIF provider for the Anthropic Claude Code CLI toolkit

[`claif_cla`](https://github.com/twardoch/claif_cla/) is a CLI and Python package that wraps the [`claude_code_sdk`](https://github.com/anthropics/claude-code-sdk-python) package for interacting with Anthropic’s [Claude Code CLI](https://github.com/anthropics/claude-code) agentic CLI toolkit based on their Claude models.

**Key Responsibilities:**

- Claude API integration
- Session management and persistence
- Tool approval strategies
- Response caching
- Session branching/merging

**Development Focus:**

- Maintain claude-code-sdk compatibility
- Enhance session features
- Improve approval strategies
- Optimize caching logic

### 2.3. `claif_gem`: CLAIF provider for the Google Gemini CLI toolkit

[`claif_gem`](https://github.com/twardoch/claif_gem/): CLI and Python package for that wraps the [Gemini CLI](https://github.com/google-gemini/gemini-cli/) agentic CLI toolkit based on Google’s Gemini models.

**Key Responsibilities:**

- Gemini CLI subprocess management
- Auto-approval and yes-mode handling
- Context length management
- System prompt configuration

**Development Focus:**

- Robust subprocess handling
- CLI argument parsing
- Timeout and error recovery
- Cross-platform compatibility

## 3. Working Principles for CLAIF Development

### 3.1. Core Development Principles

When developing for CLAIF (in any sub-project):

- **Iterate gradually**, avoiding major breaking changes to the plugin interface
- **Minimize user confirmations** while maintaining safety, especially for code operations
- **Preserve existing API contracts** unless a major version bump is planned
- **Use module-level constants** over magic numbers (e.g., `DEFAULT_TIMEOUT = 120`)
- **Check for existing utilities** in `claif.common` before implementing new ones
- **Ensure coherence** between provider implementations and the unified interface
- **Focus on minimal viable features** and ship incremental improvements
- **Write comprehensive docstrings** explaining both what and WHY, including cross-references
- **Analyze provider differences** line-by-line when implementing unified features
- **Handle provider failures gracefully** with retries, fallbacks, and clear error messages
- **Address edge cases** like network timeouts, API limits, and malformed responses
- **Let the framework handle complexity**, minimize provider-specific user decisions
- **Reduce cognitive load** through consistent naming and behavior across providers
- **Modularize provider logic** into focused, testable components
- **Favor flat provider hierarchies** over deeply nested inheritance
- **Maintain documentation**:
  - README.md (purpose and usage for each sub-project)
  - CHANGELOG.md (version history with migration notes)
  - TODO.md (planned features and known issues)
  - PROGRESS.md (implementation status for each provider)

### 3.2. Using Development Tools

Before and during development, you should:

- Use `context7` tool to check latest Python package documentation
- Consult `deepseek/deepseek-r1-0528:free` via `chat_completion` for complex architectural decisions
- Query `openai/o3` via `chat_completion` for API design and compatibility questions
- Apply `sequentialthinking` tool for solving cross-provider compatibility issues
- Search with `perplexity_ask` and `duckduckgo_web_search` for provider API updates

### 3.3. File Organization

In each source file, maintain the `this_file` record:

```python
# this_file: src/claif_cla/cli.py
"""CLI interface for the CLAIF Claude provider"""
```

### 3.4. Python-Specific Guidelines

For all CLAIF Python code:

- **PEP 8**: Consistent formatting with 120-char line limit (per pyproject.toml)
- **Descriptive names**: `query_with_retry()` not `qwr()`
- **PEP 20**: Explicit provider selection over magic
- **Type hints**: Use simple unions (`str | None` not `Optional[str]`)
- **PEP 257**: Imperative mood docstrings with provider examples
- **Modern Python**: f-strings, pattern matching for message types
- **Logging**: Loguru-based with provider-specific contexts
- **CLI scripts**: Fire & rich with uv shebang:

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = ["fire", "rich", "claif"]
# ///
# this_file: scripts/provider_test.py
```

After changes, run:

```bash
uv run uzpy run .
fd -e py -x autoflake {}
fd -e py -x pyupgrade --py312-plus {}
fd -e py -x ruff check --output-format=github --fix --unsafe-fixes {}
fd -e py -x ruff format --respect-gitignore --target-version py312 {}
python -m pytest
```

## 4. Sub-Project Specific Guidelines

### 4.1. `claif_cod`: CLAIF provider for the OpenAI Codex CLI toolkit

**Code Safety:**

- Default to review mode for all operations
- Implement diff preview before applying changes
- Maintain operation history for rollback

**Project Integration:**

- Respect .gitignore patterns
- Detect project type (Python, JS, etc.)
- Use appropriate code formatters

**Action Modes:**

- Clearly separate mode logic
- Provide mode transition safeguards
- Log all automated actions

## 5. Quality Assurance

### 5.1. Pre-Commit Checks

All sub-projects must pass:

```yaml
- repo: https://github.com/astral-sh/ruff-pre-commit
  hooks:
    - id: ruff
    - id: ruff-format
- repo: https://github.com/pre-commit/mirrors-mypy
  hooks:
    - id: mypy
```

### 5.2. Testing Strategy

1. **Unit Tests**: Provider-specific logic
2. **Integration Tests**: Provider + CLAIF core
3. **E2E Tests**: CLI commands with real providers
4. **Performance Tests**: Response time, memory usage

### 5.3. Documentation Requirements

Each sub-project must maintain:

- Comprehensive README with examples
- API reference (autodoc where possible)
- Migration guides for breaking changes
- Troubleshooting section

## 6. Virtual Team Collaboration

When developing CLAIF:

**Be creative, diligent, critical, relentless & funny!**

Lead two virtual experts:

- **"Ideot"**: Proposes creative provider features and unconventional integrations
- **"Critin"**: Critiques API design and identifies compatibility issues

The three of you shall:

- Illuminate the best provider abstraction patterns
- Process provider differences methodically
- Collaborate on cross-provider features
- Adapt when provider APIs change

If compatibility issues arise, step back and focus on the unified interface goals.

## 7. Release Coordination

Since CLAIF uses a monorepo structure:

1. Version all packages together
2. Update inter-package dependencies
3. Test all providers before release
4. Publish in order: claif → providers
5. Tag releases with `v{version}`

## 8. Final Checkpoint

When completing any CLAIF development:

**"Wait, but..."** - Review your changes:

- Does it maintain provider abstraction?
- Is the API still unified?
- Are errors handled consistently?
- Is the documentation updated?

Repeat this reflection, but stick to "minimal viable next version" philosophy.

Remember: CLAIF's strength is its unified interface. Every line of code should serve this goal while allowing providers to shine with their unique capabilities.
</file>

<file path="README.md">
# CLAIF_COD - Codex Provider for CLAIF

**CLAIF_COD** is a Python package that provides integration with OpenAI's Codex CLI as part of the CLAIF (Command-Line Artificial Intelligence Framework) ecosystem. It enables AI-powered code generation, refactoring, and manipulation through both command-line and programmatic interfaces.

## What is CLAIF_COD?

CLAIF_COD is a specialized provider that wraps the Codex CLI binary, offering:

- **AI-powered code generation and manipulation** through OpenAI's Codex models
- **Multiple action modes** for different levels of automation (review, interactive, full-auto)
- **Project-aware operations** with working directory support
- **Subprocess management** with timeout protection and error handling
- **Rich terminal output** with progress indicators and formatted tables
- **Async/await support** for modern Python applications

The package acts as a bridge between the CLAIF framework and the Codex CLI, normalizing messages and providing a consistent interface across different AI providers.

## Installation

### Prerequisites

You need to have the Codex CLI binary installed. Set the path via environment variable:
```bash
export CODEX_CLI_PATH=/path/to/codex-cli
```

### From PyPI
```bash
pip install claif_cod
```

### From Source
```bash
git clone https://github.com/twardoch/claif_cod.git
cd claif_cod
pip install -e .
```

### With CLAIF Framework
```bash
# Install CLAIF with Codex support
pip install claif[cod]
# or
pip install claif claif_cod
```

### Development Installation
```bash
# Install with all development dependencies
pip install -e ".[dev,test,docs,all]"
```

## Command Line Usage

CLAIF_COD provides a Fire-based CLI with rich terminal output:

### Basic Commands

```bash
# Simple code generation
claif-cod query "Write a Python function to calculate fibonacci numbers"

# Use specific model
claif-cod query "Refactor this code for better performance" --model o4

# Set custom parameters
claif-cod query "Add comprehensive error handling" --temperature 0.2 --max-tokens 2000
```

### Action Modes

Control how code changes are applied:

```bash
# Review mode (default) - preview all changes before applying
claif-cod query "Fix the bug in main.py" --action-mode review

# Interactive mode - approve each change individually
claif-cod query "Update all docstrings" --action-mode interactive

# Full-auto mode - apply all changes automatically
claif-cod query "Format all files" --action-mode full-auto --auto-approve
```

### Working with Projects

```bash
# Specify project directory
claif-cod query "Run tests and fix failures" --working-dir /path/to/project

# Use current directory
claif-cod query "Add type hints to all functions" --working-dir .
```

### Streaming Responses

```bash
# Stream responses in real-time
claif-cod stream "Implement a REST API with FastAPI"

# Stream with specific model
claif-cod stream "Create comprehensive unit tests" --model o4-preview
```

### Model Management

```bash
# List available models
claif-cod models

# Show model details
claif-cod model-info o4-mini

# List action modes
claif-cod modes
```

### Configuration

```bash
# Show current configuration
claif-cod config show

# Set configuration values
claif-cod config set --codex_cli_path /usr/local/bin/codex-cli
claif-cod config set --default_model o4-mini
claif-cod config set --timeout 300

# Save configuration
claif-cod config save
```

### Additional Commands

```bash
# Check service health
claif-cod health

# Show version
claif-cod version
```

## Python API Usage

### Basic Usage

```python
import asyncio
from claif_cod import query, CodexOptions

async def main():
    # Simple query
    async for message in query("Write a sorting algorithm"):
        print(message.content)
    
    # With options
    options = CodexOptions(
        model="o4",
        temperature=0.2,
        max_tokens=1500,
        action_mode="review"
    )
    async for message in query("Optimize this function", options):
        print(message.content)

asyncio.run(main())
```

### Advanced Configuration

```python
from pathlib import Path
from claif_cod import query, CodexOptions

async def generate_code():
    options = CodexOptions(
        model="o4-preview",
        temperature=0.3,
        max_tokens=2000,
        action_mode="interactive",
        working_dir=Path("./src"),
        system_prompt="You are an expert Python developer",
        auto_approve_everything=False,
        timeout=300
    )
    
    async for message in query("Create a web scraper", options):
        if message.content_type == "code":
            print(f"Generated code:\n{message.content}")
        elif message.content_type == "error":
            print(f"Error: {message.content}")
        else:
            print(message.content)
```

### Working with Transport Layer

```python
from claif_cod.transport import CodexTransport
from claif_cod.types import CodexOptions

# Create custom transport
transport = CodexTransport(
    cli_path="/usr/local/bin/codex-cli",
    timeout=600  # 10 minutes for complex operations
)

# Execute query
options = CodexOptions(model="o4", action_mode="review")
async for message in transport.query("Refactor entire module", options):
    print(f"{message.message_type}: {message.content}")
```

### Error Handling

```python
from claif.common import ProviderError, TimeoutError
from claif_cod import query, CodexOptions

async def safe_query():
    try:
        options = CodexOptions(timeout=120)
        async for message in query("Complex refactoring", options):
            print(message.content)
    except TimeoutError:
        print("Operation timed out")
    except ProviderError as e:
        print(f"Codex error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")
```

## Why CLAIF_COD is Useful

### 1. **Unified Interface**
- Consistent API across different AI providers
- Easy switching between Codex, Claude, Gemini, and others
- Standardized message format and error handling

### 2. **Safety Features**
- Default review mode prevents unwanted changes
- Timeout protection for long-running operations
- Clear error messages and logging
- Working directory isolation

### 3. **Developer Experience**
- Rich CLI with colored output and progress indicators
- Both sync and async APIs
- Type hints and IDE support
- Comprehensive documentation

### 4. **Integration**
- Works seamlessly with the CLAIF framework
- Plugin architecture for easy extension
- Configuration inheritance from CLAIF
- Compatible with existing codebases

## How It Works

### Architecture Overview

```
┌─────────────────────┐
│    User Code        │
├─────────────────────┤
│    CLAIF Core       │  ← Unified interface
├─────────────────────┤
│    CLAIF_COD        │  ← This package
├─────────────────────┤
│ CodexTransport      │  ← Subprocess management
├─────────────────────┤
│  Codex CLI Binary   │  ← External process
└─────────────────────┘
```

### Codebase Structure

```
src/claif_cod/
├── __init__.py       # Main entry point, exports query() function
├── __version__.py    # Version information (auto-generated)
├── cli.py           # Fire-based CLI with rich output
├── client.py        # Client logic for query lifecycle
├── transport.py     # Subprocess communication layer
└── types.py         # Type definitions and data structures
```

### Component Details

#### `__init__.py` - Main Entry Point
- Exports the primary `query()` async function
- Handles conversion between CLAIF and Codex options
- Provides version information
- Implements the CLAIF provider interface

#### `cli.py` - Command Line Interface
- Fire-based CLI framework
- Rich terminal output with tables and progress
- Commands: query, stream, models, health, config, modes
- Handles user input and formatting

#### `client.py` - Client Logic
- Manages the query lifecycle
- Validates options and parameters
- Coordinates with transport layer
- Normalizes messages to CLAIF format

#### `transport.py` - Transport Layer
- `CodexTransport` class for subprocess management
- CLI path discovery (env var → PATH → common locations)
- Command building with proper escaping
- JSON streaming parser for output
- Platform-specific handling (Windows, macOS, Linux)
- Timeout and error management

#### `types.py` - Type Definitions
- `CodexOptions`: Configuration dataclass
- `CodexMessage`: Message structure from Codex
- `TextBlock`, `CodeBlock`, `ErrorBlock`: Content types
- `ResultMessage`: Metadata and results
- Type hints for better IDE support

### Message Flow

1. **User Input** → CLI or Python API
2. **Option Conversion** → CLAIF options to CodexOptions
3. **Transport Layer** → Spawn Codex CLI subprocess
4. **Command Building** → Construct CLI arguments
5. **Execution** → Run subprocess with timeout
6. **Output Parsing** → Stream JSON lines
7. **Message Normalization** → Convert to CLAIF format
8. **User Output** → Yield messages to caller

### Configuration

Environment variables:
- `CODEX_CLI_PATH`: Path to Codex CLI binary
- `CODEX_DEFAULT_MODEL`: Default model (o4-mini)
- `CODEX_ACTION_MODE`: Default action mode (review)
- `CODEX_TIMEOUT`: Default timeout in seconds

Configuration file (`~/.claif/config.toml`):
```toml
[providers.codex]
enabled = true
cli_path = "/usr/local/bin/codex-cli"
default_model = "o4-mini"
default_action_mode = "review"
timeout = 180

[providers.codex.models]
available = ["o3.5", "o4-mini", "o4", "o4-preview"]
default = "o4-mini"
```

### Models Available

- **o4-mini**: Fast, efficient model for quick tasks
- **o4**: Balanced model for general use
- **o4-preview**: Latest features and capabilities
- **o3.5**: Previous generation model

### Action Modes

- **review** (default): Preview changes before applying
- **interactive**: Approve each change individually
- **full-auto**: Apply all changes automatically

## Best Practices

1. **Always start with review mode** to understand what changes will be made
2. **Use specific, clear prompts** for better results
3. **Set appropriate timeouts** for complex operations
4. **Test generated code** thoroughly before production use
5. **Use version control** before applying automated changes
6. **Configure working directory** to limit scope of operations

## Development

### Running Tests
```bash
# Run all tests
pytest

# Run with coverage
pytest --cov=claif_cod --cov-report=html

# Run specific test file
pytest tests/test_transport.py
```

### Linting and Formatting
```bash
# Run linting
ruff check src/claif_cod tests

# Format code
ruff format src/claif_cod tests

# Type checking
mypy src/claif_cod
```

### Building Documentation
```bash
# Build Sphinx docs
cd docs && make html
```

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Make your changes
4. Run tests and linting
5. Commit with descriptive message
6. Push to your fork
7. Open a Pull Request

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Links

- [GitHub Repository](https://github.com/twardoch/claif_cod)
- [PyPI Package](https://pypi.org/project/claif_cod/)
- [CLAIF Framework](https://github.com/twardoch/claif)
- [Documentation](https://claif-cod.readthedocs.io/)

## Related Projects

- [CLAIF](https://github.com/twardoch/claif) - The main framework
- [CLAIF_CLA](https://github.com/twardoch/claif_cla) - Claude provider
- [CLAIF_GEM](https://github.com/twardoch/claif_gem) - Gemini provider
</file>

</files>
